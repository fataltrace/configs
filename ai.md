# Ð¨Ð°Ð³Ð¸

## 1. Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð°Ð²Ð¸Ð»
- ÐÐ°Ð¹Ñ‚Ð¸ Ð¸Ð»Ð¸ Ð½Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ `.cursorrules`, ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ð¾Ð¹ Ñ‚ÐµÑ…Ð½Ð¾Ð»Ð¾Ð³Ð¸Ð¸ Ð¸ Ð·Ð°Ð´Ð°Ñ‡Ðµ.

## 2. ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°
- Ð’ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ð¹ Ñ„Ð¾Ñ€Ð¼Ðµ Ð¾Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚.
- ÐŸÐ¾Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚ÑŒ Ñ„Ð¾Ñ€Ð¼Ð°Ð»Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð² Ð²Ð¸Ð´Ðµ `project.md`.

## 3. Ð’ÐµÑ€Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð·Ð°Ð´Ð°Ñ‡Ð¸
- Ð—Ð°Ð´Ð°Ñ‚ÑŒ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾Ñ:  
  *Â«ÐŸÐ¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸ `project.md`. Ð’ÑÑ‘ Ð»Ð¸ Ð² Ð½Ñ‘Ð¼ Ð¿Ð¾Ð½ÑÑ‚Ð½Ð¾? ÐšÐ°ÐºÐ¸Ðµ ÐµÑÑ‚ÑŒ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹?Â»*
- ÐŸÑ€Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ.

> ÐŸÐ¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸ `@project.md`, Ð²ÑÑ‘ Ð»Ð¸ Ð² Ð½Ñ‘Ð¼ Ð¿Ð¾Ð½ÑÑ‚Ð½Ð¾?  
> Ð—Ð°Ð´Ð°Ð¹ ÑƒÑ‚Ð¾Ñ‡Ð½ÑÑŽÑ‰Ð¸Ðµ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹.  
> Ð—Ð°Ñ‚ÐµÐ¼ Ñ€Ð°ÑÐ¿Ð¸ÑˆÐ¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð½Ñ‹Ðµ Ñ€Ð¾Ð»Ð¸ Ð¸ ÑÐ¾Ð·Ð´Ð°Ð¹ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ñ€Ð¾Ð»Ð¸ Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ð¹ `.md` Ñ„Ð°Ð¹Ð» Ñ ÐµÑ‘ Ð·Ð°Ð´Ð°Ñ‡Ð°Ð¼Ð¸.

> ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ð¾! Ð¡ÐµÐ¹Ñ‡Ð°Ñ Ñ Ð¾Ñ‚Ð²ÐµÑ‡Ñƒ Ð½Ð° Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹, Ñ‚ÐµÐ±Ðµ Ð½ÑƒÐ¶Ð½Ð¾ Ð±ÑƒÐ´ÐµÑ‚ Ð²Ð½ÐµÑÑ‚Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð² ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ð¸ Ñ Ð¼Ð¾Ð¸Ð¼Ð¸ Ð¾Ñ‚Ð²ÐµÑ‚Ð°Ð¼Ð¸  
> Ð² Ñ„Ð°Ð¹Ð»Ñ‹ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð½Ñ‹Ñ… Ñ€Ð¾Ð»ÐµÐ¹ Ð¸ Ð² ÑÐ°Ð¼ @project.md 

## 4. ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ€Ð¾Ð»ÐµÐ¹ Ð¸ Ð·Ð°Ð´Ð°Ñ‡
- Ð¡Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚ÑŒ:  
  *Â«ÐšÐ°ÐºÐ¸Ðµ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð½Ñ‹Ðµ Ñ€Ð¾Ð»Ð¸ Ð½ÑƒÐ¶Ð½Ñ‹ Ð´Ð»Ñ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸?Â»*
- Ð—Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ ÐºÐ°Ð¶Ð´ÑƒÑŽ Ñ€Ð¾Ð»ÑŒ Ð¸ ÑÐ²ÑÐ·Ð°Ð½Ð½Ñ‹Ðµ Ð·Ð°Ð´Ð°Ñ‡Ð¸ Ð² Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ðµ `.md` Ñ„Ð°Ð¹Ð»Ñ‹.

## 5. ÐŸÐ»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð½Ð¾ÑÑ‚Ð¸
- ÐŸÐ¾Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚ÑŒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¿Ð¾Ñ€ÑÐ´Ð¾Ðº Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð·Ð°Ð´Ð°Ñ‡ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ñ€Ð¾Ð»Ð¸.
- ÐŸÐ¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒ Ð·Ð°Ð´Ð°Ñ‡Ð¸, Ð¿ÐµÑ€ÐµÐ´Ð°Ð²Ð°Ñ Ð½ÐµÐ¹Ñ€Ð¾ÑÐµÑ‚Ð¸:
  - Ñ„Ð°Ð¹Ð» Ñ€Ð¾Ð»Ð¸,
  - `.cursorrules`,
  - `project.md`.

---

# .cursorrules

# Python CLI Application Development Rules (2025)

Here are some best practices and rules you MUST FOLLOW:

0. **Use ONLY ENGLISH**: in the project.
1. **Use Meaningful Names**: Choose descriptive variable, function, and class names.
2. **Follow PEP 8**: Adhere to the Python Enhancement Proposal 8 style guide for formatting.
3. **Use Docstrings**: Document functions and classes with docstrings to explain their purpose.
4. **Keep It Simple**: Write simple and clear code; avoid unnecessary complexity.
5. **Use List Comprehensions**: Prefer list comprehensions for creating lists over traditional loops when appropriate.
6. **Handle Exceptions**: Use try-except blocks to handle exceptions gracefully.
7. **Use Virtual Environments**: Isolate project dependencies using virtual environments (e.g., `venv`).
8. **Write Tests**: Implement unit tests to ensure code reliability.
9. **Use Type Hints**: Utilize type hints for better code clarity and type checking.
10. **Avoid Global Variables**: Limit the use of global variables to reduce side effects.

## Project Structure Standards

### Use Modern Python Project Layout
- **ALWAYS** use `src/` layout instead of flat structure
- Place source code in `src/package_name/` directory
- Use `pyproject.toml` as the single configuration file
- Follow PEP 518/621 standards for project configuration

### CLI Application Structure
```
mycli/
â”œâ”€â”€ pyproject.toml              # Single config file (replaces setup.py, setup.cfg)
â”œâ”€â”€ README.md
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .env.example
â”œâ”€â”€ uv.lock                     # If using uv package manager
â”œâ”€â”€ src/
â”‚   â””â”€â”€ mycli/
â”‚       â”œâ”€â”€ __init__.py         # Package version
â”‚       â”œâ”€â”€ main.py             # Main entry point
â”‚       â”œâ”€â”€ cli/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ app.py          # Main CLI app
â”‚       â”‚   â”œâ”€â”€ commands/       # Individual commands
â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”‚   â”œâ”€â”€ init.py
â”‚       â”‚   â”‚   â”œâ”€â”€ build.py
â”‚       â”‚   â”‚   â””â”€â”€ deploy.py
â”‚       â”‚   â”œâ”€â”€ options.py      # Common options
â”‚       â”‚   â””â”€â”€ utils.py        # CLI utilities
â”‚       â”œâ”€â”€ core/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ config.py       # Configuration management
â”‚       â”‚   â”œâ”€â”€ exceptions.py   # Custom exceptions
â”‚       â”‚   â””â”€â”€ models.py       # Data models
â”‚       â”œâ”€â”€ services/           # Business logic
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ file_service.py
â”‚       â”‚   â””â”€â”€ api_service.py
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ __init__.py
â”‚           â”œâ”€â”€ validators.py
â”‚           â”œâ”€â”€ formatters.py
â”‚           â””â”€â”€ helpers.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py            # Pytest configuration
â”‚   â”œâ”€â”€ test_main.py
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â””â”€â”€ commands/
â”‚   â”‚       â”œâ”€â”€ test_init.py
â”‚   â”‚       â””â”€â”€ test_build.py
â”‚   â””â”€â”€ fixtures/              # Test data
â””â”€â”€ docs/
```

## Technology Stack (2025 Standards)

### Required Dependencies
- **Typer**: Modern CLI framework (preferred over Click)
- **Rich**: Beautiful terminal output with colors, progress bars, tables
- **Pydantic**: Data validation and settings management
- **Pydantic-Settings**: Environment-based configuration
- **HTTPX**: Modern HTTP client (preferred over requests)

### Development Tools
- **uv**: Fastest package manager (preferred over pip/poetry)
- **ruff**: All-in-one linter and formatter (replaces black + flake8)
- **mypy**: Type checking
- **pytest**: Testing framework
- **pre-commit**: Git hooks for code quality

### Package Manager Priority
1. **uv** (fastest, recommended for new projects 2025)
2. Poetry (mature, stable)
3. PDM (good alternative)

## Code Style and Standards

### Use Modern Python Features
- **Minimum Python version**: 3.13+
- **Always use type hints** for function parameters and return types
- Use `pathlib.Path` instead of `os.path`
- Prefer f-strings over `.format()` or `%` formatting
- Use dataclasses or Pydantic models for data structures

### CLI Framework Rules
- Use **Typer** for new CLI applications
- Structure commands in separate modules under `cli/commands/`
- Use Rich for all terminal output (colors, progress bars, tables)
- Implement proper error handling with custom exceptions
- Add `--verbose` and `--help` options to all commands

### Configuration Management
- Use **Pydantic Settings** for configuration
- Support both environment variables and config files (YAML/TOML)
- Use `APP_` prefix for environment variables
- Provide sensible defaults for all configuration options

## Code Patterns

### Main Entry Point Pattern
```python
# src/your_cli/main.py
import sys
import typer
from rich.console import Console
from rich.traceback import install

from your_cli.cli.app import app
from your_cli.core.exceptions import YourCLIError

install(show_locals=True)  # Rich tracebacks
console = Console()

def main() -> None:
    try:
        app()
    except YourCLIError as e:
        console.print(f"[red]Error:[/red] {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        console.print("\n[yellow]Operation cancelled[/yellow]")
        sys.exit(130)

if __name__ == "__main__":
    main()
```

### Command Structure Pattern
```python
# src/your_cli/cli/commands/build.py
import typer
from rich.console import Console
from rich.progress import track

console = Console()
app = typer.Typer()

@app.command()
def all(
    ctx: typer.Context,
    clean: bool = typer.Option(False, "--clean", help="Clean before build"),
    verbose: bool = typer.Option(False, "--verbose", help="Verbose output"),
) -> None:
    """Build the entire project."""
    console.print("ðŸ”¨ [bold]Building project[/bold]")
    
    tasks = ["Task 1", "Task 2", "Task 3"]
    for task in track(tasks, description="Building..."):
        # Your build logic here
        pass
    
    console.print("âœ… [green]Build completed![/green]")
```

### Configuration Pattern
```python
# src/your_cli/core/config.py
from pathlib import Path
from typing import Optional
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings

class BuildConfig(BaseModel):
    target: str = Field(default="dist/", description="Build target")
    clean: bool = Field(default=True, description="Clean before build")

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_prefix="YOURCLI_",
        env_file=".env",
        case_sensitive=False,
    )
    
    name: str = Field(default="my-project")
    version: str = Field(default="1.0.0")
    build: BuildConfig = Field(default_factory=BuildConfig)
```

## Testing Standards

### Test Structure
- Place tests in `tests/` directory
- Mirror source structure in test directory
- Use `conftest.py` for shared fixtures
- Test CLI commands using `typer.testing.CliRunner`

### Test Patterns
```python
# tests/cli/commands/test_build.py
import pytest
from typer.testing import CliRunner
from your_cli.cli.commands.build import app

def test_build_command(runner: CliRunner):
    result = runner.invoke(app, ["all"])
    assert result.exit_code == 0
    assert "Build completed!" in result.stdout
```

## Error Handling

### Custom Exceptions
```python
# src/your_cli/core/exceptions.py
class YourCLIError(Exception):
    """Base exception for your CLI."""
    pass

class ConfigError(YourCLIError):
    """Configuration related errors."""
    pass

class BuildError(YourCLIError):
    """Build related errors."""
    pass
```

## Documentation Standards

### README
- Use best practice
- Add mermaid diagrams for workflow

### Docstring Standards
- Use Google/NumPy style docstrings
- Document all public functions and classes
- Include type information in docstrings
- Provide usage examples for complex functions

## Best Practices

### Performance
- Use async/await for I/O operations
- Implement progress bars for long-running operations
- Use streaming for large file operations
- Cache expensive computations

### User Experience
- Provide clear, actionable error messages
- Use colors and formatting for better readability
- Add confirmation prompts for dangerous operations

### Security
- Validate all user inputs
- Use secure defaults for configuration
- Don't log sensitive information
- Implement proper permission checks for file operations

### Maintenance
- Write comprehensive tests (aim for >90% coverage)
- Use semantic versioning
- Maintain a CHANGELOG.md
- Document breaking changes clearly

## File Patterns to Follow

### .gitignore
```
__pycache__/
*.py[cod]
*$py.class
.Python
build/
dist/
*.egg-info/
.env
.venv/
.coverage
htmlcov/
.pytest_cache/
.mypy_cache/
.ruff_cache/
```

Always prioritize code clarity, type safety, and user experience when developing CLI applications. Your goal is to create a powerful, user-friendly CLI application that sets new standards in the field.
